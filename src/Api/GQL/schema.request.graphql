# Root Query
type Query {
  # getObsEtl: ObsETL
  # getStatus: Text!
  """
  Instantiates Model.Request with the user input.
  Successful instantiation is proof/validation of a valid request structure.
  """
  validate(request: RequestInput!): Request
  # subject(type: String): QualityMix
  # quality(
  #   name: String!,
  #   txtValues: [String!],
  #   intValues: [Int!]): Quality
  # qualities(names: [String!]!): [Quality]!
  # qualityValues(txtValues: [String!], intValues: [Int!]): QualityValues

  # measurement(name: String!): Measurement
  # measurements(types: [String!]): [Measurement!]
  # component(
  #   name: String!,
  #   txtValues: [String!],
  #   intValues: [Int!],
  #   spanValues: [SpanInput!]): Component
  # components(names: [String!]): [Component!]
  # componentValues(
  #   txtValues: [String!],
  #   intValues: [Int!],
  #   spanValues: [SpanInput!],
  #   reduced: Boolean!): ComponentValues

  # getMatrix(request: RequestInput!): Matix
  # go: Matrix
}

# Root Mutation
# type Mutation {
  # newObsEtl(value: ObsEtlInput!): ObsETL!
# }

# Request inputs
"""
A data pull from the ObsETL data.  A subset of the ObsETL universe.
The difference: any number of 'Measurements' can be defined with different
mixes of components.

The request output is a table of data.  The length of the tabel is defined
by the qualities chosen (qualities that describe the subjects).

The width of the table (number of columns or fields) is often set mostly by
the mix of components within a measurement.  Measurements and their components
have no influence on the length of the table, i.e., on the number of records.
"""
input RequestInput {
  subReq: QualityMixInput
  meaReqs: [ComponentMixInput!]
}
"""
Describes the requested mix of Subject Qualities. This mix of qualities
determines the number of Subjects included in the request (i.e., the
number of records in the requested data set)
"""
input QualityMixInput {
  subjectType: String
  qualityMix: [QualityReqInput!]!
}
input QualityReqInput {
  """
  Use this field to pull all of the values for the quality.
  """
  qualityNames: [String!]
  """
  Use this field in combination with the 'qualityValues' field to
  pull a subset of the values for that quality.
  """
  qualityName: String
  """
  This field is a filter that selects a subset of values. Thus
  it reduces the number of records.  If left empty, all of
  the qualities will be selected.
  """
  qualityValues: FieldValuesInput
}
"""
Describes which components to include in the measurement.
"""
input ComponentMixInput {
  measurementTypes: [String!]
  measurementType: String
  componentMix: [ComponentReqInput!]
}
"""
Use *componentNames* to request *all of the values* in each of the
components.
Use *componentName* to request a subset of values of a component.
"""
input ComponentReqInput {
  componentNames: [String!]
  componentName: String
  componentValues: FieldValuesCompReqInput
}
"""
A requested component needs to specify if the collection of values is meant
to create a single (reduced = True) or multiple fields in the requested
data table (Request -> Matrix).
"""
input FieldValuesCompReqInput {
  txtValues: [String!]
  intValues: [Int!]
  spanValues: [SpanInput!]
  reduced: Boolean!
}

# View of the Model
type Request {
  subReq: QualityMix
  meaReqs: [ComponentMix!]
}
type QualityMix {
  subjectType: String!
  qualities: [Quality!]!
}
type ComponentMix {
  measurementType: String!
  components: [ReqComponent!]!
}
type ReqComponent {
  componentName: String!
  values: CompReqValues!
}
type CompReqValues {
  values: ComponentValues
  reduced: Boolean!
}
